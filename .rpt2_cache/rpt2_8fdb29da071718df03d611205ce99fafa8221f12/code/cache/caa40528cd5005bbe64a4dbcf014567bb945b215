{
  "code": "import { NodeType } from \"./Node\";\r\nexport default class GraphOperations {\r\n    static FindSubGraph(oriG, subG) {\r\n        oriG.countTypeNums();\r\n        subG.countTypeNums();\r\n        console.log(\"oriG\");\r\n        oriG.printGraphic();\r\n        console.log(\"subG\");\r\n        subG.printGraphic();\r\n        for (let i = 0; i < subG.nodes.length; i++) {\r\n            let subN = subG.nodes[i];\r\n            subN.candidates = [];\r\n            for (let j = 0; j < oriG.nodes.length; j++) {\r\n                let oriN = oriG.nodes[j];\r\n                subN.ifcandidate(oriN);\r\n            }\r\n        }\r\n        subG.printCandidates();\r\n        GraphOperations.MatchRes = [];\r\n        let match = [];\r\n        GraphOperations.countMatch(oriG, subG, 0, match);\r\n        return GraphOperations.MatchRes;\r\n    }\r\n    static FindTs(oriG) {\r\n        GraphOperations.MatchRes = [];\r\n        for (let i = 0; i < oriG.nodes.length; i++) {\r\n            for (let j = 0; j < oriG.nodes[i].pointTo.length; j++) {\r\n                let tempT = oriG.nodes[oriG.nodes[i].pointTo[j]];\r\n                if (tempT.type == NodeType.T) {\r\n                    for (let k = 0; k < tempT.pointTo.length; k++) {\r\n                        let match = [i, oriG.nodes[i].pointTo[j], tempT.pointTo[k]];\r\n                        GraphOperations.MatchRes.push(match);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return GraphOperations.MatchRes;\r\n    }\r\n    static FindLs(oriG) {\r\n        GraphOperations.MatchRes = [];\r\n        for (let i = 0; i < oriG.nodes.length; i++) {\r\n            for (let j = 0; j < oriG.nodes[i].pointTo.length; j++) {\r\n                let tempN = oriG.nodes[oriG.nodes[i].pointTo[j]];\r\n                for (let k = 0; k < tempN.pointTo.length; k++) {\r\n                    let tempL = oriG.nodes[tempN.pointTo[k]];\r\n                    if (tempL.type == NodeType.l) {\r\n                        let match = [i, oriG.nodes[i].pointTo[j], tempN.pointTo[k]];\r\n                        GraphOperations.MatchRes.push(match);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return GraphOperations.MatchRes;\r\n    }\r\n    static countMatch(oriG, subG, index, match) {\r\n        if (index == subG.nodes.length) {\r\n            let subM = subG.getMatrix();\r\n            let oriM = oriG.getSubMatrix(match);\r\n            let ifaccept = true;\r\n            for (let i = 0; i < subM.length; i++) {\r\n                if (subM[i] == 1 && oriM[i] == 0) {\r\n                    ifaccept = false;\r\n                }\r\n            }\r\n            if (ifaccept) {\r\n                GraphOperations.MatchRes.push(match);\r\n            }\r\n            return true;\r\n        }\r\n        if (subG.nodes[index].candidates.length == 0) {\r\n            return false;\r\n        }\r\n        let newMatch = [];\r\n        for (let i = 0; i < subG.nodes[index].candidates.length; i++) {\r\n            let candidate = subG.nodes[index].candidates[i];\r\n            let tmpMatch = [];\r\n            for (let j = 0; j < match.length; j++) {\r\n                tmpMatch.push(match[j]);\r\n            }\r\n            tmpMatch.push(candidate);\r\n            if (!GraphOperations.countMatch(oriG, subG, index + 1, tmpMatch)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    static changeOriG(oriG, subG, newG, match) {\r\n        oriG.clearSubMatrixEdges(match);\r\n        oriG.addNewNodes(match, newG);\r\n        oriG.addNewEdges(match, newG);\r\n        oriG.countTypeNums();\r\n        console.log(\"==========\");\r\n        oriG.printGraphic();\r\n        console.log(\"==========\");\r\n    }\r\n}\r\n",
  "references": [
    "/Users/huanggaole/FanErSai/src/script/Graphic.ts",
    "/Users/huanggaole/FanErSai/src/script/Node.ts"
  ]
}
