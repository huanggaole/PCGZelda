{
  "code": "import Graphic from \"./Graphic\";\r\nimport Node, { NodeType } from \"./Node\";\r\nimport GraphOperations from \"./GraphOperations\";\r\nimport Rules from \"./Rules\";\r\nimport Region from \"./Region\";\r\nexport default class Map {\r\n    static generateWorld() {\r\n        Rules.initRules();\r\n        let oriG = new Graphic();\r\n        oriG.nodes = [new Node(0, NodeType.S, [])];\r\n        let MatchRes = GraphOperations.FindSubGraph(oriG, Rules.startpre);\r\n        let match = MatchRes[0];\r\n        GraphOperations.changeOriG(oriG, Rules.startpre, Rules.startnew, match);\r\n        for (let i = 0; i < 6; i++) {\r\n            let MatchRes = GraphOperations.FindSubGraph(oriG, Rules.addpre);\r\n            let match = MatchRes[Math.floor(Math.random() * MatchRes.length)];\r\n            if (Math.random() < 0.5) {\r\n                GraphOperations.changeOriG(oriG, Rules.addpre, Rules.add2new, match);\r\n            }\r\n            else {\r\n                GraphOperations.changeOriG(oriG, Rules.addpre, Rules.add3new, match);\r\n            }\r\n        }\r\n        MatchRes = GraphOperations.FindSubGraph(oriG, Rules.addpre);\r\n        match = MatchRes[Math.floor(Math.random() * MatchRes.length)];\r\n        GraphOperations.changeOriG(oriG, Rules.addpre, Rules.add1new, match);\r\n        oriG.countTypeNums();\r\n        oriG.printGraphic();\r\n        while (true) {\r\n            let MatchRes = GraphOperations.FindTs(oriG);\r\n            if (MatchRes.length == 0) {\r\n                break;\r\n            }\r\n            let match = MatchRes[Math.floor(Math.random() * MatchRes.length)];\r\n            if (Math.random() < 0.5) {\r\n                Rules.setDefineT1new(oriG, match);\r\n                GraphOperations.changeOriG(oriG, Rules.addpre, Rules.defineT1new, match);\r\n            }\r\n            else {\r\n                Rules.setDefineT2new(oriG, match);\r\n                GraphOperations.changeOriG(oriG, Rules.addpre, Rules.defineT2new, match);\r\n            }\r\n        }\r\n        for (let i = 0; i < 5; i++) {\r\n            let MatchRes = GraphOperations.FindLs(oriG);\r\n            if (MatchRes.length == 0) {\r\n                break;\r\n            }\r\n            let match = MatchRes[Math.floor(Math.random() * MatchRes.length)];\r\n            Rules.setDefineLnew(oriG, match);\r\n            GraphOperations.changeOriG(oriG, Rules.addpre, Rules.defineLnew, match);\r\n        }\r\n        let map = Map.GenotoPheno(oriG);\r\n        return map;\r\n    }\r\n    static setGrid(oriG, index, map, size, gridindex, unoccupied, rect) {\r\n        let res = true;\r\n        map[gridindex] = index;\r\n        let x = gridindex % (size);\r\n        let y = Math.floor((gridindex - x) / (size));\r\n        if (x < rect.minx) {\r\n            rect.minx = x;\r\n        }\r\n        if (x > rect.maxx) {\r\n            rect.maxx = x;\r\n        }\r\n        if (y < rect.miny) {\r\n            rect.miny = y;\r\n        }\r\n        if (y > rect.maxy) {\r\n            rect.maxy = y;\r\n        }\r\n        if (x > 0 && map[y * size + x - 1] == -1 && unoccupied.indexOf(y * size + x - 1) == -1) {\r\n            unoccupied.push(y * size + x - 1);\r\n        }\r\n        if (x < size - 1 && map[y * size + x + 1] == -1 && unoccupied.indexOf(y * size + x + 1) == -1) {\r\n            unoccupied.push(y * size + x + 1);\r\n        }\r\n        if (y > 0 && map[(y - 1) * size + x] == -1 && unoccupied.indexOf((y - 1) * size + x) == -1) {\r\n            unoccupied.push((y - 1) * size + x);\r\n        }\r\n        if (y < size - 1 && map[(y + 1) * size + x] == -1 && unoccupied.indexOf((y + 1) * size + x) == -1) {\r\n            unoccupied.push((y + 1) * size + x);\r\n        }\r\n        if (oriG.nodes[index].pointTo.length > unoccupied.length) {\r\n            if (unoccupied.length == 0) {\r\n                return false;\r\n            }\r\n            let randomUindex = Math.floor(Math.random() * unoccupied.length);\r\n            let newGridindex = unoccupied[randomUindex];\r\n            unoccupied = unoccupied.filter(item => item != newGridindex);\r\n            res = res && this.setGrid(oriG, index, map, size, newGridindex, unoccupied, rect);\r\n        }\r\n        else {\r\n            for (let i = 0; i < oriG.nodes[index].pointTo.length; i++) {\r\n                let randomUindex = Math.floor(Math.random() * unoccupied.length);\r\n                let newGridindex = unoccupied[randomUindex];\r\n                unoccupied = unoccupied.filter(item => item != newGridindex);\r\n                res = res && this.setGrid(oriG, oriG.nodes[index].pointTo[i], map, size, newGridindex, [], rect);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    static GenotoPheno(oriG) {\r\n        let size = Math.ceil(Math.sqrt(oriG.nodes.length)) * 2;\r\n        let map = [];\r\n        for (let j = 0; j < size; j++) {\r\n            for (let i = 0; i < size; i++) {\r\n                map.push(-1);\r\n            }\r\n        }\r\n        while (true) {\r\n            let initindex = Math.floor(size / 2) * size + Math.floor(size / 2);\r\n            let minx = initindex % size;\r\n            let maxx = initindex % size;\r\n            let miny = (initindex - minx) / size;\r\n            let maxy = (initindex - maxx) / size;\r\n            let rect = { minx, maxx, miny, maxy };\r\n            let res = this.setGrid(oriG, 0, map, size, initindex, [], rect);\r\n            if (res) {\r\n                let width = rect.maxx - rect.minx + 1;\r\n                let height = rect.maxy - rect.miny + 1;\r\n                let tmpcol = [];\r\n                for (let j = 0; j < height; j++) {\r\n                    let tmprow = [];\r\n                    for (let i = 0; i < width; i++) {\r\n                        if (map[(rect.miny + j) * size + rect.minx + i] == -1) {\r\n                            tmprow.push(null);\r\n                        }\r\n                        else {\r\n                            let index = map[(rect.miny + j) * size + rect.minx + i];\r\n                            let newregion = new Region(index);\r\n                            tmprow.push(newregion);\r\n                        }\r\n                    }\r\n                    tmpcol.push(tmprow);\r\n                }\r\n                map = tmpcol;\r\n                console.log(map);\r\n                for (let j = 0; j < height; j++) {\r\n                    for (let i = 0; i < width; i++) {\r\n                        if (map[j][i] != null) {\r\n                            let curmap = map[j][i];\r\n                            let index = curmap.index;\r\n                            curmap.node = oriG.nodes[index];\r\n                            let pointto = oriG.nodes[index].pointTo;\r\n                            if (j > 0) {\r\n                                let tmpmap = map[(j - 1)][i];\r\n                                if (tmpmap != null) {\r\n                                    let tmpindex = tmpmap.index;\r\n                                    if (pointto.indexOf(tmpindex) > -1) {\r\n                                        curmap.upConnect = true;\r\n                                        tmpmap.downConnect = true;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (j < height - 1) {\r\n                                let tmpmap = map[(j + 1)][i];\r\n                                if (tmpmap != null) {\r\n                                    let tmpindex = tmpmap.index;\r\n                                    if (pointto.indexOf(tmpindex) > -1) {\r\n                                        curmap.downConnect = true;\r\n                                        tmpmap.upConnect = true;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (i > 0) {\r\n                                let tmpmap = map[j][i - 1];\r\n                                if (tmpmap != null) {\r\n                                    let tmpindex = tmpmap.index;\r\n                                    if (pointto.indexOf(tmpindex) > -1) {\r\n                                        curmap.leftConnect = true;\r\n                                        tmpmap.rightConnect = true;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (i < width - 1) {\r\n                                let tmpmap = map[j][i + 1];\r\n                                if (tmpmap != null) {\r\n                                    let tmpindex = tmpmap.index;\r\n                                    if (pointto.indexOf(tmpindex) > -1) {\r\n                                        curmap.rightConnect = true;\r\n                                        tmpmap.leftConnect = true;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        return map;\r\n    }\r\n}\r\n",
  "references": [
    "/Users/huanggaole/FanErSai/src/script/Graphic.ts",
    "/Users/huanggaole/FanErSai/src/script/Node.ts",
    "/Users/huanggaole/FanErSai/src/script/GraphOperations.ts",
    "/Users/huanggaole/FanErSai/src/script/Rules.ts",
    "/Users/huanggaole/FanErSai/src/script/Region.ts"
  ]
}
