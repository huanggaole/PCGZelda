{
  "code": "import Node, { NodeType } from \"./Node\";\r\nexport default class Graphic {\r\n    constructor() {\r\n        this.typename = [\r\n            \"S\",\r\n            \"e\",\r\n            \"t\",\r\n            \"b\",\r\n            \"g\",\r\n            \"l\",\r\n            \"k\",\r\n            \"T\",\r\n            \"Any\"\r\n        ];\r\n    }\r\n    countTypeNums() {\r\n        for (let index = 0; index < this.nodes.length; index++) {\r\n            let node = this.nodes[index];\r\n            node.countTypeNum = [];\r\n            for (let i = 0; i < this.typename.length; i++) {\r\n                node.countTypeNum.push(0);\r\n            }\r\n            for (let i = 0; i < node.pointTo.length; i++) {\r\n                node.countTypeNum[this.nodes[node.pointTo[i]].type]++;\r\n            }\r\n        }\r\n    }\r\n    printGraphic() {\r\n        for (let i = 0; i < this.nodes.length; i++) {\r\n            let out = i + this.typename[this.nodes[i].type] + \"->\";\r\n            for (let j = 0; j < this.nodes[i].pointTo.length; j++) {\r\n                let index = this.nodes[i].pointTo[j];\r\n                out += index + this.typename[this.nodes[index].type] + \",\";\r\n            }\r\n            if (this.nodes[i].keyTo.length > 0) {\r\n                out += \"keyto:\";\r\n                for (let j = 0; j < this.nodes[i].keyTo.length; j++) {\r\n                    let index = this.nodes[i].keyTo[j];\r\n                    out += index + this.typename[this.nodes[index].type] + \",\";\r\n                }\r\n            }\r\n            console.log(out);\r\n        }\r\n    }\r\n    printCandidates() {\r\n        for (let i = 0; i < this.nodes.length; i++) {\r\n            console.log(this.nodes[i].candidates);\r\n        }\r\n    }\r\n    getMatrix() {\r\n        if (this.matrix == null) {\r\n            let matrix = [];\r\n            for (let j = 0; j < this.nodes.length; j++) {\r\n                for (let i = 0; i < this.nodes.length; i++) {\r\n                    matrix.push(0);\r\n                }\r\n            }\r\n            for (let j = 0; j < this.nodes.length; j++) {\r\n                for (let i = 0; i < this.nodes[j].pointTo.length; i++) {\r\n                    matrix[j * this.nodes.length + this.nodes[j].pointTo[i]] = 1;\r\n                }\r\n            }\r\n            this.matrix = matrix;\r\n        }\r\n        return this.matrix;\r\n    }\r\n    getSubMatrix(indices) {\r\n        let matrix = [];\r\n        for (let j = 0; j < indices.length; j++) {\r\n            for (let i = 0; i < indices.length; i++) {\r\n                matrix.push(0);\r\n            }\r\n        }\r\n        for (let j = 0; j < indices.length; j++) {\r\n            for (let i = 0; i < this.nodes[indices[j]].pointTo.length; i++) {\r\n                let pt = this.nodes[indices[j]].pointTo[i];\r\n                let newindex = indices.indexOf(pt);\r\n                if (newindex > -1) {\r\n                    matrix[j * indices.length + newindex] = 1;\r\n                }\r\n            }\r\n        }\r\n        return matrix;\r\n    }\r\n    clearSubMatrixEdges(indices) {\r\n        for (let j = 0; j < indices.length; j++) {\r\n            for (let i = 0; i < this.nodes[indices[j]].pointTo.length; i++) {\r\n                let pt = this.nodes[indices[j]].pointTo[i];\r\n                let newindex = indices.indexOf(pt);\r\n                if (newindex > -1) {\r\n                    this.nodes[indices[j]].pointTo = this.nodes[indices[j]].pointTo.filter(item => item != pt);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    addNewNodes(indices, newG) {\r\n        while (newG.nodes.length > indices.length) {\r\n            let newnode = new Node(this.nodes.length, newG.nodes[indices.length].type, []);\r\n            this.nodes.push(newnode);\r\n            indices.push(newnode.index);\r\n        }\r\n        for (let i = 0; i < newG.nodes.length; i++) {\r\n            this.nodes[indices[i]].type = newG.nodes[i].type;\r\n        }\r\n    }\r\n    addNewEdges(indices, newG) {\r\n        for (let i = 0; i < newG.nodes.length; i++) {\r\n            for (let j = 0; j < newG.nodes[i].pointTo.length; j++) {\r\n                this.nodes[indices[i]].pointTo.push(indices[newG.nodes[i].pointTo[j]]);\r\n            }\r\n            if (this.nodes[indices[i]].type == NodeType.k) {\r\n                for (let j = 0; j < newG.nodes[i].keyTo.length; j++) {\r\n                    this.nodes[indices[i]].keyTo.push(indices[newG.nodes[i].keyTo[j]]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n",
  "references": [
    "/Users/huanggaole/FanErSai/src/script/Node.ts"
  ]
}
